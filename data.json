{
  "config": {
    "inputDir": ".",
    "title": "Rob Knight",
    "outputDir": "/home/robert/projects/blog/robertknight.github.io/_site",
    "componentsDir": "/home/robert/projects/blog/robertknight.github.io/components",
    "rootUrl": "",
    "author": {
      "name": "Rob Knight",
      "photoUrl": "http://www.gravatar.com/avatar/217c7106a3d4eba3584cd38abf8ee107?s=128",
      "twitterId": "robknight_",
      "githubId": "robertknight",
      "email": "robertknight@gmail.com"
    }
  },
  "posts": [
    {
      "metadata": {
        "slug": "webpack-dll-plugins",
        "title": "Optimizing Webpack build times and improving caching with DLL bundles",
        "date": "2016-02-06T00:00:00.000Z",
        "tags": [
          "webpack"
        ]
      },
      "body": "\nWebpack's `Dll` and `DllReference` plugins are a way to split\na large JavaScript project into multiple bundles which\ncan be compiled independently. They can be used to optimize\nbuild times (both full and incremental) and improve caching\nfor users by putting code which changes infrequently into\nseparate \"library\" bundles. The term 'Dll' is short for\n_Dynamically Linked Library_ which is a feature for native Windows\napplications that solves the same problem.\n\nFor example, suppose you have an application built with\nseveral large libraries or frameworks such as `jQuery`, `Angular`\nor `React` which change relatively infrequently, plus some utility code such as `underscore` or `lodash` which you change very rarely. The `Dll` plugins enable you to\nput the utility code in one bundle, the frameworks in another and your application\ncode in a separate one.\n\nThis has several benefits:\n\n * Your can compile the library bundles separately from the application bundle.\n   This means that during typical development, you would compile your library\n   bundles once and then run Webpack in `--watch` mode to recompile your application\n   bundles as you change your app. Since the application bundle is smaller,\n   the initial build will be faster and incremental builds will usually also\n   be quicker.\n * When your users load your app, they will only need to download\n   the bundles which have changed.\n * You can avoid cluttering up the configuration for your app bundle\n   with plugins/loaders etc. that are only needed for vendor bundles\n   or vice-versa. This helps with both build speed and maintainability.\n\nFor common versions of major libraries (eg. jQuery, Angular) you can also get\nthese benefits by consuming them from a CDN such as [cdnjs](https://cdnjs.com) using `<script>` tags and you should consider doing that.\n\nThe advantage of Webpack library bundles is that you can choose\nhow to assign modules to bundles and it works with libraries that\nyou consume from `npm` and `require()` from your app code.\n\n## Creating library bundles\n\nTo partition your code into library and application bundles, you will need to create two\nWebpack configurations, one that creates the library bundle(s) and another that\ncreates the application bundle(s) that use code from the libraries.\n\nIn the configuration for your library bundle, add `DllPlugin` to the list of plugins.\n`DllPlugin` does two things:\n\n 1. It exposes a `require()` function via a global variable on the page which\n    other bundles can use to require code from that bundle.\n\n 2. It generates a JSON manifest, which is a mapping between the file paths of\n    modules inside the bundle and the integer IDs that each module has been\n\tassigned. This manifest is used by your application bundles to determine\n\twhether a library bundle provides a particular module and if so, how\n\tto access it from another bundle.\n\n```js\n// vendor-bundles.webpack.config.js\nvar webpack = require('webpack')\n\nmodule.exports = {\n  entry: {\n    // create two library bundles, one with jQuery and\n    // another with Angular and related libraries\n    'jquery': ['jquery'],\n    'angular': ['angular', 'angular-router', 'angular-sanitize']\n  },\n\n  output: {\n    filename: '[name].bundle.js',\n    path: 'dist/'\n\n    // The name of the global variable which the library's\n    // require() function will be assigned to\n    library: '[name]_lib',\n  },\n\n  plugins: {\n    new webpack.DllPlugin({\n      // The path to the manifest file which maps between\n      // modules included in a bundle and the internal IDs\n      // within that bundle\n      path: 'dist/[name]-manifest.json',\n      // The name of the global variable which the library's\n      // require function has been assigned to. This must match the\n      // output.library option above\n      name: '[name]_lib'\n    }),\n  },\n}\n```\n\nThe generated bundle will look something like this:\n\n```js\nvar angular_lib = (function (modules) {\n  // Bundle bootstrap code...\n})([\n  // Module 0 re-exports the require function,\n  // so that it becomes the value of angular_lib\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__;\n  }\n])\n```\n\nAfter this is loaded, `window.angular_lib(<id>)` can be used by any\nother code on the page to require code from that bundle. Since modules use integer IDs which are internal to the bundle, you also need\nthe JSON manifest in order to map from file path to ID.\n\nThe JSON manifest is structured like this:\n\n```js\n{\n  \"name\": \"angular_lib\",\n  \"content\": {\n    \"./node_modules/angular/index.js\": 1,\n    ...\n  }\n}\n```\n\n## Creating application bundles\n\nIn the configuration for your application bundle, you will add a `DllRefrencePlugin`\ninstance to the list of plugins, one per library that you want to consume.\n\n`DllReferencePlugin` specifies the path of a manifest previously generated by\n`DllPlugin` to search for modules.\n\nWhen Webpack encounters a `require()` in your code, it will first check the\navailable DLLs to see if one provides that code. If it does, a stub module\ncontaining a reference to that DLL will be generated. Otherwise, the actual\ncode of the required module will be included in the application bundle as normal.\n\n```js\n// app.webpack.config.js\nvar webpack = require('webpack')\n\nmodule.exports = {\n  entry: {\n    app: './src/index'\n  },\n\n  plugins: {\n    new webpack.DllReferencePlugin({\n\t  context: '.',\n\t  manifest: require('dist/jquery-manifest.json')\n\t}),\n\tnew webpack.DllReferencePlugin({\n\t  context: '.',\n\t  manifest: require('dist/angular-manifest.json')\n\t}),\n  }\n}\n```\n\nIf you look inside the generated `app.bundle.js`, you'll find code like this:\n\n```js\n// in your module\nvar angular = __webpack_require__(2)\n\n/* 2 */\n// get a reference to the bundle containing 'angular',\n// then require module (1) from that\nmodule.exports = (__webpack_require__(3))(1)\n\n/* 3 */\n// re-export the global variable created by the library\n// bundle\nmodule.exports = angular_lib\n```\n\nA minimal complete example can be found [in this Gist](https://gist.github.com/robertknight/058a194f45e77ff95fcd).\n\n\n## Comparison with other code splitting methods\n\nThe DLL plugins are not the only code-splitting mechanism available\nin Webpack. The other ones are:\n\n * [**CommonsChunkPlugin**](https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin) extracts out code that\n   is shared between multiple bundles and puts it into a separate\n   bundle. The advantage is that you don't need to specify which\n   code to put in the shared bundle, Webpack can automatically\n   identify that.\n\n   You can force specific libraries into a 'commons' chunk,\n   and this is a good solution if you only have a moderate amount\n   of vendor code.\n\n   The advantage is that you only need one Webpack configuration.\n   The disadvantage for large projects is that the 'commons'\n   chunk will be recompiled every time you run Webpack.\n\n * [**Code splitting**](https://webpack.github.io/docs/code-splitting.html) via `require.ensure()` allows lazy-loading\n   of chunks of code as particular pages or features are used.\n   This is useful to optimize the initial page load time by keeping\n   the main bundle small and then pulling in code for lesser-used\n   features on-demand.\n"
    },
    {
      "metadata": {
        "slug": "qt-widget-layout",
        "title": "Understanding the QWidget layout flow",
        "date": "2013-11-21T00:00:00.000Z",
        "tags": [
          "qt"
        ]
      },
      "body": "When layouts in a UI are not behaving as expected or performance is poor, it can be helpful to have a mental model of the layout process in order to know where to start debugging.  For web browsers there are some good resources which provide a description of the process at different levels. The layout documentation for [Qt](https://www.qt.io) describes the various layout facilities that are available but I haven't found a detailed description of the flow, so this is my attempt to explain what happens when a layout is triggered that ultimately ends up with the widgets being resized and repositioned appropriately.\n\n1. A widget's contents are modified in some way that require a layout update. Such changes can include:\n\t* Changes to the content of the widget (eg. the text in a label, content margins being altered)\n\t* Changes to the `sizePolicy()` of the widget\n\t* Changes to the layout() of the widget, such as new child widgets being added or removed\n    \n1. The widget calls `QWidget::updateGeometry()` which then performs several steps to trigger a layout:\n\t1. It invalidates any cached size information for the QWidgetItem associated with the widget in the parent layout.\n\t1. It recursively climbs up the widget tree (first to the parent widget, then the grandparent and so on), invalidating that widget's layout. The process stops when we reach a widget that is a top level window or doesn't have its own layout - we'll call this widget the top-level widget, though it might not actually be a window.\n\n1. If the top-level widget is not yet visible, then the process stops and layout is deferred until the widget is due to be shown.\n\n1. If the top-level widget is shown, a LayoutRequest event is posted asynchronously to the top-level widget, so a layout will be performed on the next pass through the event loop.\n\n1. If multiple layout requests are posted to the same top-level widget during a pass through the event loop, they will get compressed into a single layout request. This is similar to the way that multiple `QWidget::update()` requests are compressed into a single paint event.\n\n1. The top-level widget receives the LayoutRequest event on the next pass through the event loop. This can then be handled in one of two ways:\n\t1. If the widget has a layout, the layout will intercept the LayoutRequest event using an event filter and handle it by calling QLayout::activate()\n\t1. If the widget does not have a layout, it may handle the LayoutRequest event itself and manually set the geometry of its children.\n\n1. When the layout is activated, it first sets the fixed, minimum and/or maximum size constraints of the widget depending on QLayout::sizeConstraint(), using the values calculated by QLayout::minimumSize(), maximumSize() and sizeHint(). These functions will recursively proceed down the layout tree to determine the constraints for each item and produce a final size constraint for the whole layout.  This may or may not alter the current size of the widget.\n\n1.\tThe layout is then asked to resize its contents to fit the current size of the widget using QLayout::setGeometry(widget->size()). The specific implementation of the layout - whether it is a box layout, grid layout or something else then lays out its child items to fit this new size.\n\n1. For each item in the layout, the QLayoutItem::setGeometry() implementation will typically ask the item for various size parameters (minimum size, maximum size, size hint, height for width) and then decide upon a final size and position for the item. It will then invoke QLayoutItem::setGeometry() to update the position and size of the widget.\n\n1. If the layout item is itself a layout or a widget, steps 5-6 proceed recursively down the tree, updating all of the items whose constraints have been modified.\n"
    }
  ],
  "tags": {
    "webpack": [
      {
        "metadata": {
          "slug": "webpack-dll-plugins",
          "title": "Optimizing Webpack build times and improving caching with DLL bundles",
          "date": "2016-02-06T00:00:00.000Z",
          "tags": [
            "webpack"
          ]
        },
        "body": "\nWebpack's `Dll` and `DllReference` plugins are a way to split\na large JavaScript project into multiple bundles which\ncan be compiled independently. They can be used to optimize\nbuild times (both full and incremental) and improve caching\nfor users by putting code which changes infrequently into\nseparate \"library\" bundles. The term 'Dll' is short for\n_Dynamically Linked Library_ which is a feature for native Windows\napplications that solves the same problem.\n\nFor example, suppose you have an application built with\nseveral large libraries or frameworks such as `jQuery`, `Angular`\nor `React` which change relatively infrequently, plus some utility code such as `underscore` or `lodash` which you change very rarely. The `Dll` plugins enable you to\nput the utility code in one bundle, the frameworks in another and your application\ncode in a separate one.\n\nThis has several benefits:\n\n * Your can compile the library bundles separately from the application bundle.\n   This means that during typical development, you would compile your library\n   bundles once and then run Webpack in `--watch` mode to recompile your application\n   bundles as you change your app. Since the application bundle is smaller,\n   the initial build will be faster and incremental builds will usually also\n   be quicker.\n * When your users load your app, they will only need to download\n   the bundles which have changed.\n * You can avoid cluttering up the configuration for your app bundle\n   with plugins/loaders etc. that are only needed for vendor bundles\n   or vice-versa. This helps with both build speed and maintainability.\n\nFor common versions of major libraries (eg. jQuery, Angular) you can also get\nthese benefits by consuming them from a CDN such as [cdnjs](https://cdnjs.com) using `<script>` tags and you should consider doing that.\n\nThe advantage of Webpack library bundles is that you can choose\nhow to assign modules to bundles and it works with libraries that\nyou consume from `npm` and `require()` from your app code.\n\n## Creating library bundles\n\nTo partition your code into library and application bundles, you will need to create two\nWebpack configurations, one that creates the library bundle(s) and another that\ncreates the application bundle(s) that use code from the libraries.\n\nIn the configuration for your library bundle, add `DllPlugin` to the list of plugins.\n`DllPlugin` does two things:\n\n 1. It exposes a `require()` function via a global variable on the page which\n    other bundles can use to require code from that bundle.\n\n 2. It generates a JSON manifest, which is a mapping between the file paths of\n    modules inside the bundle and the integer IDs that each module has been\n\tassigned. This manifest is used by your application bundles to determine\n\twhether a library bundle provides a particular module and if so, how\n\tto access it from another bundle.\n\n```js\n// vendor-bundles.webpack.config.js\nvar webpack = require('webpack')\n\nmodule.exports = {\n  entry: {\n    // create two library bundles, one with jQuery and\n    // another with Angular and related libraries\n    'jquery': ['jquery'],\n    'angular': ['angular', 'angular-router', 'angular-sanitize']\n  },\n\n  output: {\n    filename: '[name].bundle.js',\n    path: 'dist/'\n\n    // The name of the global variable which the library's\n    // require() function will be assigned to\n    library: '[name]_lib',\n  },\n\n  plugins: {\n    new webpack.DllPlugin({\n      // The path to the manifest file which maps between\n      // modules included in a bundle and the internal IDs\n      // within that bundle\n      path: 'dist/[name]-manifest.json',\n      // The name of the global variable which the library's\n      // require function has been assigned to. This must match the\n      // output.library option above\n      name: '[name]_lib'\n    }),\n  },\n}\n```\n\nThe generated bundle will look something like this:\n\n```js\nvar angular_lib = (function (modules) {\n  // Bundle bootstrap code...\n})([\n  // Module 0 re-exports the require function,\n  // so that it becomes the value of angular_lib\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__;\n  }\n])\n```\n\nAfter this is loaded, `window.angular_lib(<id>)` can be used by any\nother code on the page to require code from that bundle. Since modules use integer IDs which are internal to the bundle, you also need\nthe JSON manifest in order to map from file path to ID.\n\nThe JSON manifest is structured like this:\n\n```js\n{\n  \"name\": \"angular_lib\",\n  \"content\": {\n    \"./node_modules/angular/index.js\": 1,\n    ...\n  }\n}\n```\n\n## Creating application bundles\n\nIn the configuration for your application bundle, you will add a `DllRefrencePlugin`\ninstance to the list of plugins, one per library that you want to consume.\n\n`DllReferencePlugin` specifies the path of a manifest previously generated by\n`DllPlugin` to search for modules.\n\nWhen Webpack encounters a `require()` in your code, it will first check the\navailable DLLs to see if one provides that code. If it does, a stub module\ncontaining a reference to that DLL will be generated. Otherwise, the actual\ncode of the required module will be included in the application bundle as normal.\n\n```js\n// app.webpack.config.js\nvar webpack = require('webpack')\n\nmodule.exports = {\n  entry: {\n    app: './src/index'\n  },\n\n  plugins: {\n    new webpack.DllReferencePlugin({\n\t  context: '.',\n\t  manifest: require('dist/jquery-manifest.json')\n\t}),\n\tnew webpack.DllReferencePlugin({\n\t  context: '.',\n\t  manifest: require('dist/angular-manifest.json')\n\t}),\n  }\n}\n```\n\nIf you look inside the generated `app.bundle.js`, you'll find code like this:\n\n```js\n// in your module\nvar angular = __webpack_require__(2)\n\n/* 2 */\n// get a reference to the bundle containing 'angular',\n// then require module (1) from that\nmodule.exports = (__webpack_require__(3))(1)\n\n/* 3 */\n// re-export the global variable created by the library\n// bundle\nmodule.exports = angular_lib\n```\n\nA minimal complete example can be found [in this Gist](https://gist.github.com/robertknight/058a194f45e77ff95fcd).\n\n\n## Comparison with other code splitting methods\n\nThe DLL plugins are not the only code-splitting mechanism available\nin Webpack. The other ones are:\n\n * [**CommonsChunkPlugin**](https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin) extracts out code that\n   is shared between multiple bundles and puts it into a separate\n   bundle. The advantage is that you don't need to specify which\n   code to put in the shared bundle, Webpack can automatically\n   identify that.\n\n   You can force specific libraries into a 'commons' chunk,\n   and this is a good solution if you only have a moderate amount\n   of vendor code.\n\n   The advantage is that you only need one Webpack configuration.\n   The disadvantage for large projects is that the 'commons'\n   chunk will be recompiled every time you run Webpack.\n\n * [**Code splitting**](https://webpack.github.io/docs/code-splitting.html) via `require.ensure()` allows lazy-loading\n   of chunks of code as particular pages or features are used.\n   This is useful to optimize the initial page load time by keeping\n   the main bundle small and then pulling in code for lesser-used\n   features on-demand.\n"
      }
    ],
    "qt": [
      {
        "metadata": {
          "slug": "qt-widget-layout",
          "title": "Understanding the QWidget layout flow",
          "date": "2013-11-21T00:00:00.000Z",
          "tags": [
            "qt"
          ]
        },
        "body": "When layouts in a UI are not behaving as expected or performance is poor, it can be helpful to have a mental model of the layout process in order to know where to start debugging.  For web browsers there are some good resources which provide a description of the process at different levels. The layout documentation for [Qt](https://www.qt.io) describes the various layout facilities that are available but I haven't found a detailed description of the flow, so this is my attempt to explain what happens when a layout is triggered that ultimately ends up with the widgets being resized and repositioned appropriately.\n\n1. A widget's contents are modified in some way that require a layout update. Such changes can include:\n\t* Changes to the content of the widget (eg. the text in a label, content margins being altered)\n\t* Changes to the `sizePolicy()` of the widget\n\t* Changes to the layout() of the widget, such as new child widgets being added or removed\n    \n1. The widget calls `QWidget::updateGeometry()` which then performs several steps to trigger a layout:\n\t1. It invalidates any cached size information for the QWidgetItem associated with the widget in the parent layout.\n\t1. It recursively climbs up the widget tree (first to the parent widget, then the grandparent and so on), invalidating that widget's layout. The process stops when we reach a widget that is a top level window or doesn't have its own layout - we'll call this widget the top-level widget, though it might not actually be a window.\n\n1. If the top-level widget is not yet visible, then the process stops and layout is deferred until the widget is due to be shown.\n\n1. If the top-level widget is shown, a LayoutRequest event is posted asynchronously to the top-level widget, so a layout will be performed on the next pass through the event loop.\n\n1. If multiple layout requests are posted to the same top-level widget during a pass through the event loop, they will get compressed into a single layout request. This is similar to the way that multiple `QWidget::update()` requests are compressed into a single paint event.\n\n1. The top-level widget receives the LayoutRequest event on the next pass through the event loop. This can then be handled in one of two ways:\n\t1. If the widget has a layout, the layout will intercept the LayoutRequest event using an event filter and handle it by calling QLayout::activate()\n\t1. If the widget does not have a layout, it may handle the LayoutRequest event itself and manually set the geometry of its children.\n\n1. When the layout is activated, it first sets the fixed, minimum and/or maximum size constraints of the widget depending on QLayout::sizeConstraint(), using the values calculated by QLayout::minimumSize(), maximumSize() and sizeHint(). These functions will recursively proceed down the layout tree to determine the constraints for each item and produce a final size constraint for the whole layout.  This may or may not alter the current size of the widget.\n\n1.\tThe layout is then asked to resize its contents to fit the current size of the widget using QLayout::setGeometry(widget->size()). The specific implementation of the layout - whether it is a box layout, grid layout or something else then lays out its child items to fit this new size.\n\n1. For each item in the layout, the QLayoutItem::setGeometry() implementation will typically ask the item for various size parameters (minimum size, maximum size, size hint, height for width) and then decide upon a final size and position for the item. It will then invoke QLayoutItem::setGeometry() to update the position and size of the widget.\n\n1. If the layout item is itself a layout or a widget, steps 5-6 proceed recursively down the tree, updating all of the items whose constraints have been modified.\n"
      }
    ]
  }
}