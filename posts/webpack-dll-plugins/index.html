<html>
<head>
	<meta charset="UTF-8">
	<title>Optimizing Webpack build times and improving caching with DLL bundles</title>
	<link rel="stylesheet" href="/theme/zenburn.css">
	<link rel="stylesheet" href="/theme/theme.css">
	<meta name="viewport" content="width=device-width">
</head>
<body>
	<div id="app"><div><div class="header-top-banner"><span class="header-name"><a href="/">Rob Knight</a></span><span class="header-section-separator"></span><a href="https://twitter.com/robknight_"><img src="/theme/images/twitter-white.png" class="header-social-link-image"/></a><a href="https://github.com/robertknight"><img src="/theme/images/github-white-120x120.png" class="header-social-link-image"/></a><a href="mailto:robertknight@gmail.com"><img src="/theme/images/email-48x38.png" class="header-social-link-image"/></a></div><div class="content post"><a class="fonts-title post-title" href="/posts/webpack-dll-plugins">Optimizing Webpack build times and improving caching with DLL bundles</a><div class="fonts-date post-date">Sat Feb 06 2016</div><div class="post-tag-list"><a class="post-tag-list-tag" href="/posts/tagged/webpack">webpack</a></div><div class="fonts-article-body post-content"><div><p>Webpack&#x27;s <code>Dll</code> and <code>DllReference</code> plugins are a way to split a large JavaScript project into multiple bundles which can be compiled independently. They can be used to optimize build times (both full and incremental) and improve caching for users by putting code which changes infrequently into separate &quot;library&quot; bundles. The term &#x27;Dll&#x27; is short for <em>Dynamically Linked Library</em> which is a feature for native Windows applications that solves the same problem.</p> <p>For example, suppose you have an application built with several large libraries or frameworks such as <code>jQuery</code>, <code>Angular</code> or <code>React</code> which change relatively infrequently, plus some utility code such as <code>underscore</code> or <code>lodash</code> which you change very rarely. The <code>Dll</code> plugins enable you to put the utility code in one bundle, the frameworks in another and your application code in a separate one.</p> <p>This has several benefits:</p> <ul> <li>Your can compile the library bundles separately from the application bundle. This means that during typical development, you would compile your library bundles once and then run Webpack in <code>--watch</code> mode to recompile your application bundles as you change your app. Since the application bundle is smaller, the initial build will be faster and incremental builds will usually also be quicker.</li> <li>When your users load your app, they will only need to download the bundles which have changed.</li> <li>You can avoid cluttering up the configuration for your app bundle with plugins/loaders etc. that are only needed for vendor bundles or vice-versa. This helps with both build speed and maintainability.</li> </ul> <p>For common versions of major libraries (eg. jQuery, Angular) you can also get these benefits by consuming them from a CDN such as <a href="https://cdnjs.com">cdnjs</a> using <code>&lt;script&gt;</code> tags and you should consider doing that.</p> <p>The advantage of Webpack library bundles is that you can choose how to assign modules to bundles and it works with libraries that you consume from <code>npm</code> and <code>require()</code> from your app code.</p> <h2 id="creating-library-bundles">Creating library bundles</h2> <p>To partition your code into library and application bundles, you will need to create two Webpack configurations, one that creates the library bundle(s) and another that creates the application bundle(s) that use code from the libraries.</p> <p>In the configuration for your library bundle, add <code>DllPlugin</code> to the list of plugins. <code>DllPlugin</code> does two things:</p> <ol> <li><p>It exposes a <code>require()</code> function via a global variable on the page which other bundles can use to require code from that bundle.</p> </li> <li><p>It generates a JSON manifest, which is a mapping between the file paths of modules inside the bundle and the integer IDs that each module has been assigned. This manifest is used by your application bundles to determine whether a library bundle provides a particular module and if so, how to access it from another bundle.</p> </li> </ol> <pre><code class="lang-js"><div class="hljs"><span class="hljs-comment">// vendor-bundles.webpack.config.js</span><br/><span class="hljs-keyword">var</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>)<br/><br/><span class="hljs-module"><span class="hljs-keyword">module</span>.exports = </span>{<br/>  entry: {<br/>    <span class="hljs-comment">// create two library bundles, one with jQuery and</span><br/>    <span class="hljs-comment">// another with Angular and related libraries</span><br/>    <span class="hljs-string">&#x27;jquery&#x27;</span>: [<span class="hljs-string">&#x27;jquery&#x27;</span>],<br/>    <span class="hljs-string">&#x27;angular&#x27;</span>: [<span class="hljs-string">&#x27;angular&#x27;</span>, <span class="hljs-string">&#x27;angular-router&#x27;</span>, <span class="hljs-string">&#x27;angular-sanitize&#x27;</span>]<br/>  },<br/><br/>  output: {<br/>    filename: <span class="hljs-string">&#x27;[name].bundle.js&#x27;</span>,<br/>    path: <span class="hljs-string">&#x27;dist/&#x27;</span>,<br/><br/>    <span class="hljs-comment">// The name of the global variable which the library&#x27;s</span><br/>    <span class="hljs-comment">// require() function will be assigned to</span><br/>    library: <span class="hljs-string">&#x27;[name]_lib&#x27;</span>,<br/>  },<br/><br/>  plugins: [<br/>    <span class="hljs-keyword">new</span> webpack.DllPlugin({<br/>      <span class="hljs-comment">// The path to the manifest file which maps between</span><br/>      <span class="hljs-comment">// modules included in a bundle and the internal IDs</span><br/>      <span class="hljs-comment">// within that bundle</span><br/>      path: <span class="hljs-string">&#x27;dist/[name]-manifest.json&#x27;</span>,<br/>      <span class="hljs-comment">// The name of the global variable which the library&#x27;s</span><br/>      <span class="hljs-comment">// require function has been assigned to. This must match the</span><br/>      <span class="hljs-comment">// output.library option above</span><br/>      name: <span class="hljs-string">&#x27;[name]_lib&#x27;</span><br/>    }),<br/>  ],<br/>}</div> </code></pre> <p>The generated bundle will look something like this:</p> <pre><code class="lang-js"><div class="hljs"><span class="hljs-keyword">var</span> angular_lib = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(modules)</span> </span>{<br/>  <span class="hljs-comment">// Bundle bootstrap code...</span><br/>})([<br/>  <span class="hljs-comment">// Module 0 re-exports the require function,</span><br/>  <span class="hljs-comment">// so that it becomes the value of angular_lib</span><br/>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(module, exports, __webpack_require__)</span> </span>{<br/>    <span class="hljs-built_in">module</span>.exports = __webpack_require__;<br/>  }<br/>])</div> </code></pre> <p>After this is loaded, <code>window.angular_lib(&lt;id&gt;)</code> can be used by any other code on the page to require code from that bundle. Since modules use integer IDs which are internal to the bundle, you also need the JSON manifest in order to map from file path to ID.</p> <p>The JSON manifest is structured like this:</p> <pre><code class="lang-js"><div class="hljs"><span class="hljs-collection">{<br/>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;angular_lib&quot;</span>,<br/>  <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-collection">{<br/>    <span class="hljs-string">&quot;./node_modules/angular/index.js&quot;</span>: <span class="hljs-number">1</span>,<br/>    ...<br/>  }</span><br/>}</span></div> </code></pre> <h2 id="creating-application-bundles">Creating application bundles</h2> <p>In the configuration for your application bundle, you will add a <code>DllRefrencePlugin</code> instance to the list of plugins, one per library that you want to consume.</p> <p><code>DllReferencePlugin</code> specifies the path of a manifest previously generated by <code>DllPlugin</code> to search for modules.</p> <p>When Webpack encounters a <code>require()</code> in your code, it will first check the available DLLs to see if one provides that code. If it does, a stub module containing a reference to that DLL will be generated. Otherwise, the actual code of the required module will be included in the application bundle as normal.</p> <pre><code class="lang-js"><div class="hljs"><span class="hljs-comment">// app.webpack.config.js</span><br/><span class="hljs-keyword">var</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>)<br/><br/><span class="hljs-module"><span class="hljs-keyword">module</span>.exports = </span>{<br/>  entry: {<br/>    app: <span class="hljs-string">&#x27;./src/index&#x27;</span><br/>  },<br/><br/>  plugins: [<br/>    <span class="hljs-keyword">new</span> webpack.DllReferencePlugin({<br/>      context: <span class="hljs-string">&#x27;.&#x27;</span>,<br/>      manifest: <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./dist/jquery-manifest.json&#x27;</span>)<br/>    }),<br/>    <span class="hljs-keyword">new</span> webpack.DllReferencePlugin({<br/>      context: <span class="hljs-string">&#x27;.&#x27;</span>,<br/>      manifest: <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./dist/angular-manifest.json&#x27;</span>)<br/>    }),<br/>  ]<br/>}</div> </code></pre> <p>If you look inside the generated <code>app.bundle.js</code>, you&#x27;ll find code like this:</p> <pre><code class="lang-js"><div class="hljs"><span class="hljs-comment">// in your module</span><br/><span class="hljs-tag">var</span> angular = __webpack_require__(<span class="hljs-number">2</span>)<br/><br/><span class="hljs-comment">/* 2 */</span><br/><span class="hljs-comment">// get a reference to the bundle containing &#x27;angular&#x27;,</span><br/><span class="hljs-comment">// then require module (1) from that</span><br/>module<span class="hljs-class">.exports</span> = (__webpack_require__(<span class="hljs-number">3</span>))(<span class="hljs-number">1</span>)<br/><br/><span class="hljs-comment">/* 3 */</span><br/><span class="hljs-comment">// re-export the global variable created by the library</span><br/><span class="hljs-comment">// bundle</span><br/>module<span class="hljs-class">.exports</span> = angular_lib</div> </code></pre> <p>A minimal complete example can be found <a href="https://gist.github.com/robertknight/058a194f45e77ff95fcd">in this Gist</a>.</p> <h2 id="comparison-with-other-code-splitting-methods">Comparison with other code splitting methods</h2> <p>The DLL plugins are not the only code-splitting mechanism available in Webpack. The other ones are:</p> <ul> <li><p><a href="https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin"><strong>CommonsChunkPlugin</strong></a> extracts out code that is shared between multiple bundles and puts it into a separate bundle. The advantage is that you don&#x27;t need to specify which code to put in the shared bundle, Webpack can automatically identify that.</p> <p>You can force specific libraries into a &#x27;commons&#x27; chunk, and this is a good solution if you only have a moderate amount of vendor code.</p> <p>The advantage is that you only need one Webpack configuration. The disadvantage for large projects is that the &#x27;commons&#x27; chunk will be recompiled every time you run Webpack.</p> </li> <li><p><a href="https://webpack.github.io/docs/code-splitting.html"><strong>Code splitting</strong></a> via <code>require.ensure()</code> allows lazy-loading of chunks of code as particular pages or features are used. This is useful to optimize the initial page load time by keeping the main bundle small and then pulling in code for lesser-used features on-demand.</p> </li> </ul> </div></div><script src="https://hypothes.is/embed.js" async=""></script></div></div></div>
</body>
</html>

