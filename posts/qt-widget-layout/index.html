<html>
<head>
	<meta charset="UTF-8">
	<title>Understanding the QWidget layout flow</title>
	<link rel="stylesheet" href="/theme/zenburn.css">
	<link rel="stylesheet" href="/theme/theme.css">
	<meta name="viewport" content="width=device-width">
</head>
<body>
	<div id="app"><div data-reactid=".219zjhb4kjk" data-react-checksum="908231047"><div class="header-top-banner" data-reactid=".219zjhb4kjk.0"><span class="header-name" data-reactid=".219zjhb4kjk.0.0"><a class="" href="/" data-reactid=".219zjhb4kjk.0.0.0">Rob Knight</a></span><span class="header-section-separator" data-reactid=".219zjhb4kjk.0.1"></span><a href="https://twitter.com/robknight_" data-reactid=".219zjhb4kjk.0.2:$twitter"><img src="/theme/images/twitter-white.png" class="header-social-link-image" data-reactid=".219zjhb4kjk.0.2:$twitter.0"></a><a href="https://github.com/robertknight" data-reactid=".219zjhb4kjk.0.2:$github"><img src="/theme/images/github-white-120x120.png" class="header-social-link-image" data-reactid=".219zjhb4kjk.0.2:$github.0"></a><a href="mailto:robertknight@gmail.com" data-reactid=".219zjhb4kjk.0.2:$email"><img src="/theme/images/email-48x38.png" class="header-social-link-image" data-reactid=".219zjhb4kjk.0.2:$email.0"></a></div><div class="content post" data-reactid=".219zjhb4kjk.1"><a class="fonts-title post-title active" href="/posts/qt-widget-layout" data-reactid=".219zjhb4kjk.1.0">Understanding the QWidget layout flow</a><div class="fonts-date post-date" data-reactid=".219zjhb4kjk.1.1">Thu Nov 21 2013</div><div class="post-tag-list" data-reactid=".219zjhb4kjk.1.2"><a class="post-tag-list-tag" href="/posts/tagged/qt" data-reactid=".219zjhb4kjk.1.2.$tag-qt">qt</a></div><div class="fonts-article-body post-content" data-reactid=".219zjhb4kjk.1.3"><div data-reactid=".219zjhb4kjk.1.3.$post"><p data-reactid=".219zjhb4kjk.1.3.$post.0"><span data-reactid=".219zjhb4kjk.1.3.$post.0.0">When layouts in a UI are not behaving as expected or performance is poor, it can be helpful to have a mental model of the layout process in order to know where to start debugging.  For web browsers there are some good resources which provide a description of the process at different levels. The layout documentation for </span><a href="https://www.qt.io" data-reactid=".219zjhb4kjk.1.3.$post.0.1">Qt</a><span data-reactid=".219zjhb4kjk.1.3.$post.0.2"> describes the various layout facilities that are available but I haven&#x27;t found a detailed description of the flow, so this is my attempt to explain what happens when a layout is triggered that ultimately ends up with the widgets being resized and repositioned appropriately.</span></p><span data-reactid=".219zjhb4kjk.1.3.$post.1"> </span><ol data-reactid=".219zjhb4kjk.1.3.$post.2"><span data-reactid=".219zjhb4kjk.1.3.$post.2.0"> </span><li data-reactid=".219zjhb4kjk.1.3.$post.2.1"><p data-reactid=".219zjhb4kjk.1.3.$post.2.1.0">A widget&#x27;s contents are modified in some way that require a layout update. Such changes can include:</p><span data-reactid=".219zjhb4kjk.1.3.$post.2.1.1"> </span><ul data-reactid=".219zjhb4kjk.1.3.$post.2.1.2"><span data-reactid=".219zjhb4kjk.1.3.$post.2.1.2.0"> </span><li data-reactid=".219zjhb4kjk.1.3.$post.2.1.2.1">Changes to the content of the widget (eg. the text in a label, content margins being altered)</li><span data-reactid=".219zjhb4kjk.1.3.$post.2.1.2.2"> </span><li data-reactid=".219zjhb4kjk.1.3.$post.2.1.2.3"><span data-reactid=".219zjhb4kjk.1.3.$post.2.1.2.3.0">Changes to the </span><code data-reactid=".219zjhb4kjk.1.3.$post.2.1.2.3.1">sizePolicy()</code><span data-reactid=".219zjhb4kjk.1.3.$post.2.1.2.3.2"> of the widget</span></li><span data-reactid=".219zjhb4kjk.1.3.$post.2.1.2.4"> </span><li data-reactid=".219zjhb4kjk.1.3.$post.2.1.2.5">Changes to the layout() of the widget, such as new child widgets being added or removed</li><span data-reactid=".219zjhb4kjk.1.3.$post.2.1.2.6"> </span></ul><span data-reactid=".219zjhb4kjk.1.3.$post.2.1.3"> </span></li><span data-reactid=".219zjhb4kjk.1.3.$post.2.2"> </span><li data-reactid=".219zjhb4kjk.1.3.$post.2.3"><p data-reactid=".219zjhb4kjk.1.3.$post.2.3.0">The widget calls QWidget::updateGeometry() which then performs several steps to trigger a layout:</p><span data-reactid=".219zjhb4kjk.1.3.$post.2.3.1"> </span><ol data-reactid=".219zjhb4kjk.1.3.$post.2.3.2"><span data-reactid=".219zjhb4kjk.1.3.$post.2.3.2.0"> </span><li data-reactid=".219zjhb4kjk.1.3.$post.2.3.2.1">It invalidates any cached size information for the QWidgetItem associated with the widget in the parent layout.</li><span data-reactid=".219zjhb4kjk.1.3.$post.2.3.2.2"> </span><li data-reactid=".219zjhb4kjk.1.3.$post.2.3.2.3">It recursively climbs up the widget tree (first to the parent widget, then the grandparent and so on), invalidating that widget&#x27;s layout. The process stops when we reach a widget that is a top level window or doesn&#x27;t have its own layout - we&#x27;ll call this widget the top-level widget, though it might not actually be a window.</li><span data-reactid=".219zjhb4kjk.1.3.$post.2.3.2.4"> </span></ol><span data-reactid=".219zjhb4kjk.1.3.$post.2.3.3"> </span></li><span data-reactid=".219zjhb4kjk.1.3.$post.2.4"> </span><li data-reactid=".219zjhb4kjk.1.3.$post.2.5"><p data-reactid=".219zjhb4kjk.1.3.$post.2.5.0">If the top-level widget is not yet visible, then the process stops and layout is deferred until the widget is due to be shown.</p><span data-reactid=".219zjhb4kjk.1.3.$post.2.5.1"> </span></li><span data-reactid=".219zjhb4kjk.1.3.$post.2.6"> </span><li data-reactid=".219zjhb4kjk.1.3.$post.2.7"><p data-reactid=".219zjhb4kjk.1.3.$post.2.7.0">If the top-level widget is shown, a LayoutRequest event is posted asynchronously to the top-level widget, so a layout will be performed on the next pass through the event loop.</p><span data-reactid=".219zjhb4kjk.1.3.$post.2.7.1"> </span></li><span data-reactid=".219zjhb4kjk.1.3.$post.2.8"> </span><li data-reactid=".219zjhb4kjk.1.3.$post.2.9"><p data-reactid=".219zjhb4kjk.1.3.$post.2.9.0">If multiple layout requests are posted to the same top-level widget during a pass through the event loop, they will get compressed into a single layout request. This is similar to the way that multiple QWidget::update() requests are compressed into a single paint event.</p><span data-reactid=".219zjhb4kjk.1.3.$post.2.9.1"> </span></li><span data-reactid=".219zjhb4kjk.1.3.$post.2.a"> </span><li data-reactid=".219zjhb4kjk.1.3.$post.2.b"><p data-reactid=".219zjhb4kjk.1.3.$post.2.b.0">The top-level widget receives the LayoutRequest event on the next pass through the event loop. This can then be handled in one of two ways:</p><span data-reactid=".219zjhb4kjk.1.3.$post.2.b.1"> </span><ol data-reactid=".219zjhb4kjk.1.3.$post.2.b.2"><span data-reactid=".219zjhb4kjk.1.3.$post.2.b.2.0"> </span><li data-reactid=".219zjhb4kjk.1.3.$post.2.b.2.1">If the widget has a layout, the layout will intercept the LayoutRequest event using an event filter and handle it by calling QLayout::activate()</li><span data-reactid=".219zjhb4kjk.1.3.$post.2.b.2.2"> </span><li data-reactid=".219zjhb4kjk.1.3.$post.2.b.2.3">If the widget does not have a layout, it may handle the LayoutRequest event itself and manually set the geometry of its children.</li><span data-reactid=".219zjhb4kjk.1.3.$post.2.b.2.4"> </span></ol><span data-reactid=".219zjhb4kjk.1.3.$post.2.b.3"> </span></li><span data-reactid=".219zjhb4kjk.1.3.$post.2.c"> </span><li data-reactid=".219zjhb4kjk.1.3.$post.2.d"><p data-reactid=".219zjhb4kjk.1.3.$post.2.d.0">When the layout is activated, it first sets the fixed, minimum and/or maximum size constraints of the widget depending on QLayout::sizeConstraint(), using the values calculated by QLayout::minimumSize(), maximumSize() and sizeHint(). These functions will recursively proceed down the layout tree to determine the constraints for each item and produce a final size constraint for the whole layout.  This may or may not alter the current size of the widget.</p><span data-reactid=".219zjhb4kjk.1.3.$post.2.d.1"> </span></li><span data-reactid=".219zjhb4kjk.1.3.$post.2.e"> </span><li data-reactid=".219zjhb4kjk.1.3.$post.2.f"><p data-reactid=".219zjhb4kjk.1.3.$post.2.f.0">The layout is then asked to resize its contents to fit the current size of the widget using QLayout::setGeometry(widget-&gt;size()). The specific implementation of the layout - whether it is a box layout, grid layout or something else then lays out its child items to fit this new size.</p><span data-reactid=".219zjhb4kjk.1.3.$post.2.f.1"> </span></li><span data-reactid=".219zjhb4kjk.1.3.$post.2.g"> </span><li data-reactid=".219zjhb4kjk.1.3.$post.2.h"><p data-reactid=".219zjhb4kjk.1.3.$post.2.h.0">For each item in the layout, the QLayoutItem::setGeometry() implementation will typically ask the item for various size parameters (minimum size, maximum size, size hint, height for width) and then decide upon a final size and position for the item. It will then invoke QLayoutItem::setGeometry() to update the position and size of the widget.</p><span data-reactid=".219zjhb4kjk.1.3.$post.2.h.1"> </span></li><span data-reactid=".219zjhb4kjk.1.3.$post.2.i"> </span><li data-reactid=".219zjhb4kjk.1.3.$post.2.j"><p data-reactid=".219zjhb4kjk.1.3.$post.2.j.0">If the layout item is itself a layout or a widget, steps 5-6 proceed recursively down the tree, updating all of the items whose constraints have been modified.</p><span data-reactid=".219zjhb4kjk.1.3.$post.2.j.1"> </span></li><span data-reactid=".219zjhb4kjk.1.3.$post.2.k"> </span></ol><span data-reactid=".219zjhb4kjk.1.3.$post.3"> </span></div></div><div class="comment-box" data-reactid=".219zjhb4kjk.1.4"><div id="disqus_thread" data-reactid=".219zjhb4kjk.1.4.0"></div><script src="https://robertknight.disqus.com/embed.js" async type="text/javascript" data-reactid=".219zjhb4kjk.1.4.1"></script></div></div></div></div>
	<script>var appRoot = '';</script>
	<script defer src="&#x2F;vendor.bundle.js"></script>
	<script defer src="&#x2F;client.bundle.js"></script>
	<script defer src="&#x2F;components.bundle.js"></script>
</body>
</html>

