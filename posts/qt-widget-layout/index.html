<html>
<head>
	<meta charset="UTF-8">
	<title>Understanding the QWidget layout flow</title>
	<link rel="stylesheet" href="/theme/zenburn.css">
	<link rel="stylesheet" href="/theme/theme.css">
	<meta name="viewport" content="width=device-width">
</head>
<body>
	<div id="app"><div><div class="header-top-banner"><span class="header-name"><a href="/">Rob Knight</a></span><span class="header-section-separator"></span><a href="https://twitter.com/robknight_"><img src="/theme/images/twitter-white.png" class="header-social-link-image"/></a><a href="https://github.com/robertknight"><img src="/theme/images/github-white-120x120.png" class="header-social-link-image"/></a><a href="mailto:robertknight@gmail.com"><img src="/theme/images/email-48x38.png" class="header-social-link-image"/></a></div><div class="content post"><a class="fonts-title post-title" href="/posts/qt-widget-layout">Understanding the QWidget layout flow</a><div class="fonts-date post-date">Thu Nov 21 2013</div><div class="post-tag-list"><a class="post-tag-list-tag" href="/posts/tagged/qt">qt</a></div><div class="fonts-article-body post-content"><div><p>When layouts in a UI are not behaving as expected or performance is poor, it can be helpful to have a mental model of the layout process in order to know where to start debugging.  For web browsers there are some good resources which provide a description of the process at different levels. The layout documentation for <a href="https://www.qt.io">Qt</a> describes the various layout facilities that are available but I haven&#x27;t found a detailed description of the flow, so this is my attempt to explain what happens when a layout is triggered that ultimately ends up with the widgets being resized and repositioned appropriately.</p> <ol> <li><p>A widget&#x27;s contents are modified in some way that require a layout update. Such changes can include:</p> <ul> <li>Changes to the content of the widget (eg. the text in a label, content margins being altered)</li> <li>Changes to the <code>sizePolicy()</code> of the widget</li> <li>Changes to the layout() of the widget, such as new child widgets being added or removed</li> </ul> </li> <li><p>The widget calls <code>QWidget::updateGeometry()</code> which then performs several steps to trigger a layout:</p> <ol> <li>It invalidates any cached size information for the QWidgetItem associated with the widget in the parent layout.</li> <li>It recursively climbs up the widget tree (first to the parent widget, then the grandparent and so on), invalidating that widget&#x27;s layout. The process stops when we reach a widget that is a top level window or doesn&#x27;t have its own layout - we&#x27;ll call this widget the top-level widget, though it might not actually be a window.</li> </ol> </li> <li><p>If the top-level widget is not yet visible, then the process stops and layout is deferred until the widget is due to be shown.</p> </li> <li><p>If the top-level widget is shown, a LayoutRequest event is posted asynchronously to the top-level widget, so a layout will be performed on the next pass through the event loop.</p> </li> <li><p>If multiple layout requests are posted to the same top-level widget during a pass through the event loop, they will get compressed into a single layout request. This is similar to the way that multiple <code>QWidget::update()</code> requests are compressed into a single paint event.</p> </li> <li><p>The top-level widget receives the LayoutRequest event on the next pass through the event loop. This can then be handled in one of two ways:</p> <ol> <li>If the widget has a layout, the layout will intercept the LayoutRequest event using an event filter and handle it by calling QLayout::activate()</li> <li>If the widget does not have a layout, it may handle the LayoutRequest event itself and manually set the geometry of its children.</li> </ol> </li> <li><p>When the layout is activated, it first sets the fixed, minimum and/or maximum size constraints of the widget depending on QLayout::sizeConstraint(), using the values calculated by QLayout::minimumSize(), maximumSize() and sizeHint(). These functions will recursively proceed down the layout tree to determine the constraints for each item and produce a final size constraint for the whole layout.  This may or may not alter the current size of the widget.</p> </li> <li><p>The layout is then asked to resize its contents to fit the current size of the widget using QLayout::setGeometry(widget-&gt;size()). The specific implementation of the layout - whether it is a box layout, grid layout or something else then lays out its child items to fit this new size.</p> </li> <li><p>For each item in the layout, the QLayoutItem::setGeometry() implementation will typically ask the item for various size parameters (minimum size, maximum size, size hint, height for width) and then decide upon a final size and position for the item. It will then invoke QLayoutItem::setGeometry() to update the position and size of the widget.</p> </li> <li><p>If the layout item is itself a layout or a widget, steps 5-6 proceed recursively down the tree, updating all of the items whose constraints have been modified.</p> </li> </ol> </div></div><script src="https://hypothes.is/embed.js" async=""></script></div></div></div>
</body>
</html>

