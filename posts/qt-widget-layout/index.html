<html>
<head>
	<meta charset="UTF-8">
	<title>Understanding the QWidget layout flow</title>
	<link rel="stylesheet" href="/theme/theme.css">
</head>
<body>
	<div id="app"><div data-reactid=".10xmdtdmdq8" data-react-checksum="-2017721014"><div class="header-top-banner" data-reactid=".10xmdtdmdq8.0"><span class="header-name" data-reactid=".10xmdtdmdq8.0.0"><a href="/" data-reactid=".10xmdtdmdq8.0.0.0">Rob Knight</a></span><span class="header-section-separator" data-reactid=".10xmdtdmdq8.0.1"></span><a href="https://twitter.com/robknight_" data-reactid=".10xmdtdmdq8.0.2:$twitter"><img src="/theme/images/twitter-white.png" class="header-social-link-image" data-reactid=".10xmdtdmdq8.0.2:$twitter.0"></a><a href="https://github.com/robertknight" data-reactid=".10xmdtdmdq8.0.2:$github"><img src="/theme/images/github-white-120x120.png" class="header-social-link-image" data-reactid=".10xmdtdmdq8.0.2:$github.0"></a><a href="mailto:robertknight@gmail.com" data-reactid=".10xmdtdmdq8.0.2:$email"><img src="/theme/images/email-48x38.png" class="header-social-link-image" data-reactid=".10xmdtdmdq8.0.2:$email.0"></a></div><div class="content post" data-reactid=".10xmdtdmdq8.1"><a href="/posts/qt-widget-layout" class="fonts-title post-title" data-reactid=".10xmdtdmdq8.1.0">Understanding the QWidget layout flow</a><div class="fonts-date post-date" data-reactid=".10xmdtdmdq8.1.1">Thu Nov 21 2013</div><div class="post-tag-list" data-reactid=".10xmdtdmdq8.1.2"><a href="/posts/tagged/qt" class="post-tag-list-tag" data-reactid=".10xmdtdmdq8.1.2.$tag-qt">qt</a></div><div class="fonts-article-body post-content" data-reactid=".10xmdtdmdq8.1.3"><div data-reactid=".10xmdtdmdq8.1.3.$post"><p data-reactid=".10xmdtdmdq8.1.3.$post.0"><span data-reactid=".10xmdtdmdq8.1.3.$post.0.0">When layouts in a UI are not behaving as expected or performance is poor, it can be helpful to have a mental model of the layout process in order to know where to start debugging.  For web browsers there are some good resources which provide a description of the process at different levels. The layout documentation for </span><a href="https://www.qt.io" data-reactid=".10xmdtdmdq8.1.3.$post.0.1">Qt</a><span data-reactid=".10xmdtdmdq8.1.3.$post.0.2"> describes the various layout facilities that are available but I haven&#x27;t found a detailed description of the flow, so this is my attempt to explain what happens when a layout is triggered that ultimately ends up with the widgets being resized and repositioned appropriately.</span></p><ol data-reactid=".10xmdtdmdq8.1.3.$post.1"><li data-reactid=".10xmdtdmdq8.1.3.$post.1.0"><p data-reactid=".10xmdtdmdq8.1.3.$post.1.0.0">A widget&#x27;s contents are modified in some way that require a layout update. Such changes can include:</p><ul data-reactid=".10xmdtdmdq8.1.3.$post.1.0.1"><li data-reactid=".10xmdtdmdq8.1.3.$post.1.0.1.0">Changes to the content of the widget (eg. the text in a label, content margins being altered)</li><li data-reactid=".10xmdtdmdq8.1.3.$post.1.0.1.1"><span data-reactid=".10xmdtdmdq8.1.3.$post.1.0.1.1.0">Changes to the </span><code data-reactid=".10xmdtdmdq8.1.3.$post.1.0.1.1.1">sizePolicy()</code><span data-reactid=".10xmdtdmdq8.1.3.$post.1.0.1.1.2"> of the widget</span></li><li data-reactid=".10xmdtdmdq8.1.3.$post.1.0.1.2">Changes to the layout() of the widget, such as new child widgets being added or removed</li></ul></li><li data-reactid=".10xmdtdmdq8.1.3.$post.1.1"><p data-reactid=".10xmdtdmdq8.1.3.$post.1.1.0">The widget calls QWidget::updateGeometry() which then performs several steps to trigger a layout:</p><ol data-reactid=".10xmdtdmdq8.1.3.$post.1.1.1"><li data-reactid=".10xmdtdmdq8.1.3.$post.1.1.1.0">It invalidates any cached size information for the QWidgetItem associated with the widget in the parent layout.</li><li data-reactid=".10xmdtdmdq8.1.3.$post.1.1.1.1">It recursively climbs up the widget tree (first to the parent widget, then the grandparent and so on), invalidating that widget&#x27;s layout. The process stops when we reach a widget that is a top level window or doesn&#x27;t have its own layout - we&#x27;ll call this widget the top-level widget, though it might not actually be a window.</li></ol></li><li data-reactid=".10xmdtdmdq8.1.3.$post.1.2"><p data-reactid=".10xmdtdmdq8.1.3.$post.1.2.0">If the top-level widget is not yet visible, then the process stops and layout is deferred until the widget is due to be shown.</p></li><li data-reactid=".10xmdtdmdq8.1.3.$post.1.3"><p data-reactid=".10xmdtdmdq8.1.3.$post.1.3.0">If the top-level widget is shown, a LayoutRequest event is posted asynchronously to the top-level widget, so a layout will be performed on the next pass through the event loop.</p></li><li data-reactid=".10xmdtdmdq8.1.3.$post.1.4"><p data-reactid=".10xmdtdmdq8.1.3.$post.1.4.0">If multiple layout requests are posted to the same top-level widget during a pass through the event loop, they will get compressed into a single layout request. This is similar to the way that multiple QWidget::update() requests are compressed into a single paint event.</p></li><li data-reactid=".10xmdtdmdq8.1.3.$post.1.5"><p data-reactid=".10xmdtdmdq8.1.3.$post.1.5.0">The top-level widget receives the LayoutRequest event on the next pass through the event loop. This can then be handled in one of two ways:</p><ol data-reactid=".10xmdtdmdq8.1.3.$post.1.5.1"><li data-reactid=".10xmdtdmdq8.1.3.$post.1.5.1.0">If the widget has a layout, the layout will intercept the LayoutRequest event using an event filter and handle it by calling QLayout::activate()</li><li data-reactid=".10xmdtdmdq8.1.3.$post.1.5.1.1">If the widget does not have a layout, it may handle the LayoutRequest event itself and manually set the geometry of its children.</li></ol></li><li data-reactid=".10xmdtdmdq8.1.3.$post.1.6"><p data-reactid=".10xmdtdmdq8.1.3.$post.1.6.0">When the layout is activated, it first sets the fixed, minimum and/or maximum size constraints of the widget depending on QLayout::sizeConstraint(), using the values calculated by QLayout::minimumSize(), maximumSize() and sizeHint(). These functions will recursively proceed down the layout tree to determine the constraints for each item and produce a final size constraint for the whole layout.  This may or may not alter the current size of the widget.</p></li><li data-reactid=".10xmdtdmdq8.1.3.$post.1.7"><p data-reactid=".10xmdtdmdq8.1.3.$post.1.7.0">The layout is then asked to resize its contents to fit the current size of the widget using QLayout::setGeometry(widget-&gt;size()). The specific implementation of the layout - whether it is a box layout, grid layout or something else then lays out its child items to fit this new size.</p></li><li data-reactid=".10xmdtdmdq8.1.3.$post.1.8"><p data-reactid=".10xmdtdmdq8.1.3.$post.1.8.0">For each item in the layout, the QLayoutItem::setGeometry() implementation will typically ask the item for various size parameters (minimum size, maximum size, size hint, height for width) and then decide upon a final size and position for the item. It will then invoke QLayoutItem::setGeometry() to update the position and size of the widget.</p></li><li data-reactid=".10xmdtdmdq8.1.3.$post.1.9"><p data-reactid=".10xmdtdmdq8.1.3.$post.1.9.0">If the layout item is itself a layout or a widget, steps 5-6 proceed recursively down the tree, updating all of the items whose constraints have been modified.</p></li></ol></div></div><div class="comment-box" data-reactid=".10xmdtdmdq8.1.4"><div id="disqus_thread" data-reactid=".10xmdtdmdq8.1.4.0"></div><script src="https://robertknight.disqus.com/embed.js" async type="text/javascript" data-reactid=".10xmdtdmdq8.1.4.1"></script></div></div></div></div>
	<script>var appRoot = '';</script>
	<script src="&#x2F;vendor.bundle.js"></script>
	<script src="&#x2F;client.bundle.js"></script>
	<script src="&#x2F;components.bundle.js"></script>
</body>
</html>

